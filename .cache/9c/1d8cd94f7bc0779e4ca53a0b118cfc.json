{"id":"../node_modules/@chainsafe/libp2p-noise/dist/src/utils.js","dependencies":[{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js.map","includedInParent":true,"mtime":1638722720598},{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\src\\utils.ts","includedInParent":true,"mtime":1638722719753},{"name":"C:\\Users\\matte\\Documents\\SKR\\package.json","includedInParent":true,"mtime":1638722727563},{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\package.json","includedInParent":true,"mtime":1638722719245},{"name":"@stablelib/hkdf","loc":{"line":26,"column":23},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@stablelib\\hkdf\\lib\\hkdf.js"},{"name":"@stablelib/sha256","loc":{"line":27,"column":25},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@stablelib\\sha256\\lib\\sha256.js"},{"name":"@stablelib/x25519","loc":{"line":28,"column":36},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@stablelib\\x25519\\lib\\x25519.js"},{"name":"buffer","loc":{"line":29,"column":25},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\buffer\\index.js"},{"name":"peer-id","loc":{"line":30,"column":42},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\peer-id\\src\\index.js"},{"name":"libp2p-crypto","loc":{"line":31,"column":32},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\libp2p-crypto\\src\\index.js"},{"name":"./proto/payload","loc":{"line":32,"column":26},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\proto\\payload.js"},{"name":"uint8arrays/equals","loc":{"line":33,"column":25},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\uint8arrays\\cjs\\src\\equals.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\nconst hkdf_1 = require(\"@stablelib/hkdf\");\nconst sha256_1 = require(\"@stablelib/sha256\");\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst buffer_1 = require(\"buffer\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\nconst payload_1 = require(\"./proto/payload\");\nconst equals_1 = require(\"uint8arrays/equals\");\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\nfunction generateKeypair() {\n    const keypair = x25519.generateKeyPair();\n    return {\n        publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n        privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n    };\n}\nexports.generateKeypair = generateKeypair;\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);\n    return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\nexports.getPayload = getPayload;\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n    const payloadInit = NoiseHandshakePayloadProto.create({\n        identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n        identitySig: signedPayload,\n        data: earlyData !== null && earlyData !== void 0 ? earlyData : null\n    });\n    return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\nexports.createHandshakePayload = createHandshakePayload;\nasync function signPayload(peerId, payload) {\n    return buffer_1.Buffer.from(await peerId.privKey.sign(payload));\n}\nexports.signPayload = signPayload;\nasync function getPeerIdFromPayload(payload) {\n    return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\nfunction decodePayload(payload) {\n    return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\nexports.decodePayload = decodePayload;\nfunction getHandshakePayload(publicKey) {\n    return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\nexports.getHandshakePayload = getHandshakePayload;\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n    const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n    return equals_1.equals(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n    const identityKey = buffer_1.Buffer.from(payload.identityKey);\n    if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n        throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n    const generatedPayload = getHandshakePayload(noiseStaticKey);\n    // Unmarshaling from PublicKey protobuf\n    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n    // TODO remove this after libp2p-crypto ships proper types\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n        throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n    return await peer_id_1.default.createFromPubKey(identityKey);\n}\nexports.verifySignedPayload = verifySignedPayload;\nfunction getHkdf(ck, ikm) {\n    const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);\n    const okmU8Array = hkdf.expand(96);\n    const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);\n    const k1 = okm.slice(0, 32);\n    const k2 = okm.slice(32, 64);\n    const k3 = okm.slice(64, 96);\n    return [k1, k2, k3];\n}\nexports.getHkdf = getHkdf;\nfunction isValidPublicKey(pk) {\n    if (!buffer_1.Buffer.isBuffer(pk)) {\n        return false;\n    }\n    if (pk.length !== 32) {\n        return false;\n    }\n    return true;\n}\nexports.isValidPublicKey = isValidPublicKey;\n"},"sourceMaps":{"js":{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,0CAAsC;AACtC,8CAA0C;AAC1C,0DAA2C;AAC3C,mCAA+B;AAC/B,sDAA4B;AAC5B,iDAAoC;AAIpC,6CAAoC;AACpC,+CAA+D;AAE/D,MAAM,0BAA0B,GAAG,YAAE,CAAC,qBAAqB,CAAA;AAE3D,SAAgB,eAAe;IAC7B,MAAM,OAAO,GAAG,MAAM,CAAC,eAAe,EAAE,CAAA;IAExC,OAAO;QACL,SAAS,EAAE,eAAM,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC;QACxG,UAAU,EAAE,eAAM,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC;KAC1G,CAAA;AACH,CAAC;AAPD,0CAOC;AAEM,KAAK,UAAU,UAAU,CAC9B,SAAiB,EACjB,eAAsB,EACtB,SAAiB;IAEjB,MAAM,aAAa,GAAG,MAAM,WAAW,CAAC,SAAS,EAAE,mBAAmB,CAAC,eAAe,CAAC,CAAC,CAAA;IACxF,MAAM,gBAAgB,GAAG,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,eAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;IAErD,OAAO,sBAAsB,CAC3B,SAAS,CAAC,aAAa,EAAE,EACzB,aAAa,EACb,gBAAgB,CACjB,CAAA;AACH,CAAC;AAbD,gCAaC;AAED,SAAgB,sBAAsB,CACpC,eAA2B,EAC3B,aAAyB,EACzB,SAAsB;IAEtB,MAAM,WAAW,GAAG,0BAA0B,CAAC,MAAM,CAAC;QACpD,WAAW,EAAE,eAAM,CAAC,IAAI,CAAC,eAAe,CAAC;QACzC,WAAW,EAAE,aAAa;QAC1B,IAAI,EAAE,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,IAAI;KACxB,CAAC,CAAA;IAEF,OAAO,eAAM,CAAC,IAAI,CAAC,0BAA0B,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,MAAM,EAAE,CAAC,CAAA;AAC7E,CAAC;AAZD,wDAYC;AAEM,KAAK,UAAU,WAAW,CAAE,MAAc,EAAE,OAAc;IAC/D,OAAO,eAAM,CAAC,IAAI,CAAC,MAAM,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAA;AACxD,CAAC;AAFD,kCAEC;AAEM,KAAK,UAAU,oBAAoB,CAAE,OAAkC;IAC5E,OAAO,MAAM,iBAAM,CAAC,gBAAgB,CAAC,eAAM,CAAC,IAAI,CAAC,OAAO,CAAC,WAAyB,CAAC,CAAC,CAAA;AACtF,CAAC;AAFD,oDAEC;AAED,SAAgB,aAAa,CAAE,OAAyB;IACtD,OAAO,0BAA0B,CAAC,QAAQ,CACxC,0BAA0B,CAAC,MAAM,CAAC,eAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CACvC,CAAA;AACpB,CAAC;AAJD,sCAIC;AAED,SAAgB,mBAAmB,CAAE,SAAgB;IACnD,OAAO,eAAM,CAAC,MAAM,CAAC,CAAC,eAAM,CAAC,IAAI,CAAC,0BAA0B,CAAC,EAAE,SAAS,CAAC,CAAC,CAAA;AAC5E,CAAC;AAFD,kDAEC;AAED,KAAK,UAAU,aAAa,CAAE,MAAkB,EAAE,iBAAwB;IACxE,MAAM,eAAe,GAAG,MAAM,iBAAM,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,CAAA;IACxE,OAAO,eAAgB,CAAC,eAAe,CAAC,EAAE,EAAE,MAAM,CAAC,CAAA;AACrD,CAAC;AAED;;;;;;;GAOG;AACI,KAAK,UAAU,mBAAmB,CACvC,cAAqB,EACrB,OAAkC,EAClC,UAAkB;IAElB,MAAM,WAAW,GAAG,eAAM,CAAC,IAAI,CAAC,OAAO,CAAC,WAAyB,CAAC,CAAA;IAClE,IAAI,CAAC,CAAC,MAAM,aAAa,CAAC,UAAU,CAAC,EAAE,EAAE,WAAW,CAAC,CAAC,EAAE;QACtD,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAA;KAC5D;IACD,MAAM,gBAAgB,GAAG,mBAAmB,CAAC,cAAc,CAAC,CAAA;IAC5D,uCAAuC;IACvC,MAAM,SAAS,GAAG,oBAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAA;IACtD,0DAA0D;IAC1D,kEAAkE;IAClE,IAAI,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,gBAAgB,EAAE,eAAM,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,EAAE;QACjG,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAA;KACzE;IACD,OAAO,MAAM,iBAAM,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAA;AACnD,CAAC;AAlBD,kDAkBC;AAED,SAAgB,OAAO,CAAE,EAAW,EAAE,GAAU;IAC9C,MAAM,IAAI,GAAG,IAAI,WAAI,CAAC,eAAM,EAAE,GAAG,EAAE,EAAE,CAAC,CAAA;IACtC,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;IAClC,MAAM,GAAG,GAAG,eAAM,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,MAAM,CAAC,CAAA;IAEpF,MAAM,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAA;IAC3B,MAAM,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAA;IAC5B,MAAM,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAA;IAE5B,OAAO,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAA;AACrB,CAAC;AAVD,0BAUC;AAED,SAAgB,gBAAgB,CAAE,EAAS;IACzC,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE;QACxB,OAAO,KAAK,CAAA;KACb;IAED,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,EAAE;QACpB,OAAO,KAAK,CAAA;KACb;IAED,OAAO,IAAI,CAAA;AACb,CAAC;AAVD,4CAUC","sourcesContent":["import { HKDF } from '@stablelib/hkdf'\nimport { SHA256 } from '@stablelib/sha256'\nimport * as x25519 from '@stablelib/x25519'\nimport { Buffer } from 'buffer'\nimport PeerId from 'peer-id'\nimport { keys } from 'libp2p-crypto'\nimport { KeyPair } from './@types/libp2p'\nimport { bytes, bytes32 } from './@types/basic'\nimport { Hkdf, INoisePayload } from './@types/handshake'\nimport { pb } from './proto/payload'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\n\nconst NoiseHandshakePayloadProto = pb.NoiseHandshakePayload\n\nexport function generateKeypair (): KeyPair {\n  const keypair = x25519.generateKeyPair()\n\n  return {\n    publicKey: Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),\n    privateKey: Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)\n  }\n}\n\nexport async function getPayload (\n  localPeer: PeerId,\n  staticPublicKey: bytes,\n  earlyData?: bytes\n): Promise<bytes> {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey))\n  const earlyDataPayload = earlyData ?? Buffer.alloc(0)\n\n  return createHandshakePayload(\n    localPeer.marshalPubKey(),\n    signedPayload,\n    earlyDataPayload\n  )\n}\n\nexport function createHandshakePayload (\n  libp2pPublicKey: Uint8Array,\n  signedPayload: Uint8Array,\n  earlyData?: Uint8Array\n): bytes {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData ?? null\n  })\n\n  return Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish())\n}\n\nexport async function signPayload (peerId: PeerId, payload: bytes): Promise<bytes> {\n  return Buffer.from(await peerId.privKey.sign(payload))\n}\n\nexport async function getPeerIdFromPayload (payload: pb.INoiseHandshakePayload): Promise<PeerId> {\n  return await PeerId.createFromPubKey(Buffer.from(payload.identityKey as Uint8Array))\n}\n\nexport function decodePayload (payload: bytes|Uint8Array): pb.INoiseHandshakePayload {\n  return NoiseHandshakePayloadProto.toObject(\n    NoiseHandshakePayloadProto.decode(Buffer.from(payload))\n  ) as INoisePayload\n}\n\nexport function getHandshakePayload (publicKey: bytes): bytes {\n  return Buffer.concat([Buffer.from('noise-libp2p-static-key:'), publicKey])\n}\n\nasync function isValidPeerId (peerId: Uint8Array, publicKeyProtobuf: bytes): Promise<boolean> {\n  const generatedPeerId = await PeerId.createFromPubKey(publicKeyProtobuf)\n  return uint8ArrayEquals(generatedPeerId.id, peerId)\n}\n\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload (\n  noiseStaticKey: bytes,\n  payload: pb.INoiseHandshakePayload,\n  remotePeer: PeerId\n): Promise<PeerId> {\n  const identityKey = Buffer.from(payload.identityKey as Uint8Array)\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\")\n  }\n  const generatedPayload = getHandshakePayload(noiseStaticKey)\n  // Unmarshaling from PublicKey protobuf\n  const publicKey = keys.unmarshalPublicKey(identityKey)\n  // TODO remove this after libp2p-crypto ships proper types\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  if (!payload.identitySig || !publicKey.verify(generatedPayload, Buffer.from(payload.identitySig))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\")\n  }\n  return await PeerId.createFromPubKey(identityKey)\n}\n\nexport function getHkdf (ck: bytes32, ikm: bytes): Hkdf {\n  const hkdf = new HKDF(SHA256, ikm, ck)\n  const okmU8Array = hkdf.expand(96)\n  const okm = Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length)\n\n  const k1 = okm.slice(0, 32)\n  const k2 = okm.slice(32, 64)\n  const k3 = okm.slice(64, 96)\n\n  return [k1, k2, k3]\n}\n\nexport function isValidPublicKey (pk: bytes): boolean {\n  if (!Buffer.isBuffer(pk)) {\n    return false\n  }\n\n  if (pk.length !== 32) {\n    return false\n  }\n\n  return true\n}\n"]}},"error":null,"hash":"0fcf7ab0ec5f25bb1b01d94941407bd0","cacheData":{"env":{}}}