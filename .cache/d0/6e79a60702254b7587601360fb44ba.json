{"id":"../node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js","dependencies":[{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js.map","includedInParent":true,"mtime":1638722720653},{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\src\\handshakes\\abstract-handshake.ts","includedInParent":true,"mtime":1638722720613},{"name":"C:\\Users\\matte\\Documents\\SKR\\package.json","includedInParent":true,"mtime":1638722727563},{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\package.json","includedInParent":true,"mtime":1638722719245},{"name":"buffer","loc":{"line":23,"column":25},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js","resolved":"C:\\Users\\matte\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\buffer\\index.js"},{"name":"@stablelib/x25519","loc":{"line":24,"column":36},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@stablelib\\x25519\\lib\\x25519.js"},{"name":"@stablelib/sha256","loc":{"line":25,"column":36},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@stablelib\\sha256\\lib\\sha256.js"},{"name":"@stablelib/chacha20poly1305","loc":{"line":26,"column":35},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@stablelib\\chacha20poly1305\\lib\\chacha20poly1305.js"},{"name":"../utils","loc":{"line":27,"column":24},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\utils.js"},{"name":"../logger","loc":{"line":28,"column":25},"parent":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\handshakes\\abstract-handshake.js","resolved":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\logger.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\nconst buffer_1 = require(\"buffer\");\nconst x25519 = __importStar(require(\"@stablelib/x25519\"));\nconst SHA256 = __importStar(require(\"@stablelib/sha256\"));\nconst chacha20poly1305_1 = require(\"@stablelib/chacha20poly1305\");\nconst utils_1 = require(\"../utils\");\nconst logger_1 = require(\"../logger\");\nexports.MIN_NONCE = 0;\nclass AbstractHandshake {\n    encryptWithAd(cs, ad, plaintext) {\n        const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return e;\n    }\n    decryptWithAd(cs, ad, ciphertext) {\n        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return { plaintext, valid };\n    }\n    // Cipher state related\n    hasKey(cs) {\n        return !this.isEmptyKey(cs.k);\n    }\n    setNonce(cs, nonce) {\n        cs.n = nonce;\n    }\n    createEmptyKey() {\n        return buffer_1.Buffer.alloc(32);\n    }\n    isEmptyKey(k) {\n        const emptyKey = this.createEmptyKey();\n        return emptyKey.equals(k);\n    }\n    incrementNonce(n) {\n        return n + 1;\n    }\n    nonceToBytes(n) {\n        const nonce = buffer_1.Buffer.alloc(12);\n        nonce.writeUInt32LE(n, 4);\n        return nonce;\n    }\n    encrypt(k, n, ad, plaintext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n        const encryptedMessage = ctx.seal(nonce, plaintext, ad);\n        return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);\n    }\n    encryptAndHash(ss, plaintext) {\n        let ciphertext;\n        if (this.hasKey(ss.cs)) {\n            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n        }\n        else {\n            ciphertext = plaintext;\n        }\n        this.mixHash(ss, ciphertext);\n        return ciphertext;\n    }\n    decrypt(k, n, ad, ciphertext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);\n        const encryptedMessage = ctx.open(nonce, ciphertext, ad);\n        if (encryptedMessage) {\n            return {\n                plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),\n                valid: true\n            };\n        }\n        else {\n            return {\n                plaintext: buffer_1.Buffer.from(''),\n                valid: false\n            };\n        }\n    }\n    decryptAndHash(ss, ciphertext) {\n        let plaintext;\n        let valid = true;\n        if (this.hasKey(ss.cs)) {\n            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n        }\n        else {\n            plaintext = ciphertext;\n        }\n        this.mixHash(ss, ciphertext);\n        return { plaintext, valid };\n    }\n    dh(privateKey, publicKey) {\n        try {\n            const derivedU8 = x25519.sharedKey(privateKey, publicKey);\n            const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);\n            const result = buffer_1.Buffer.alloc(32);\n            derived.copy(result);\n            return result;\n        }\n        catch (e) {\n            logger_1.logger(e.message);\n            return buffer_1.Buffer.alloc(32);\n        }\n    }\n    mixHash(ss, data) {\n        ss.h = this.getHash(ss.h, data);\n    }\n    getHash(a, b) {\n        const hash = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));\n        return buffer_1.Buffer.from(hash.buffer, hash.byteOffset, hash.length);\n    }\n    mixKey(ss, ikm) {\n        const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n        ss.cs = this.initializeKey(tempK);\n        ss.ck = ck;\n    }\n    initializeKey(k) {\n        const n = exports.MIN_NONCE;\n        return { k, n };\n    }\n    // Symmetric state related\n    initializeSymmetric(protocolName) {\n        const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n        const h = this.hashProtocolName(protocolNameBytes);\n        const ck = h;\n        const key = this.createEmptyKey();\n        const cs = this.initializeKey(key);\n        return { cs, ck, h };\n    }\n    hashProtocolName(protocolName) {\n        if (protocolName.length <= 32) {\n            const h = buffer_1.Buffer.alloc(32);\n            protocolName.copy(h);\n            return h;\n        }\n        else {\n            return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n        }\n    }\n    split(ss) {\n        const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n        const cs1 = this.initializeKey(tempk1);\n        const cs2 = this.initializeKey(tempk2);\n        return { cs1, cs2 };\n    }\n    writeMessageRegular(cs, payload) {\n        const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n        const ne = this.createEmptyKey();\n        const ns = buffer_1.Buffer.alloc(0);\n        return { ne, ns, ciphertext };\n    }\n    readMessageRegular(cs, message) {\n        return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n    }\n}\nexports.AbstractHandshake = AbstractHandshake;\n"},"sourceMaps":{"js":{"version":3,"file":"abstract-handshake.js","sourceRoot":"","sources":["../../../src/handshakes/abstract-handshake.ts"],"names":[],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer'\nimport * as x25519 from '@stablelib/x25519'\nimport * as SHA256 from '@stablelib/sha256'\nimport { ChaCha20Poly1305 } from '@stablelib/chacha20poly1305'\n\nimport { bytes, bytes32, uint32 } from '../@types/basic'\nimport { CipherState, MessageBuffer, SymmetricState } from '../@types/handshake'\nimport { getHkdf } from '../utils'\nimport { logger } from '../logger'\n\nexport const MIN_NONCE = 0\n\nexport abstract class AbstractHandshake {\n  public encryptWithAd (cs: CipherState, ad: bytes, plaintext: bytes): bytes {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext)\n    this.setNonce(cs, this.incrementNonce(cs.n))\n\n    return e\n  }\n\n  public decryptWithAd (cs: CipherState, ad: bytes, ciphertext: bytes): {plaintext: bytes, valid: boolean} {\n    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext)\n    this.setNonce(cs, this.incrementNonce(cs.n))\n\n    return { plaintext, valid }\n  }\n\n  // Cipher state related\n  protected hasKey (cs: CipherState): boolean {\n    return !this.isEmptyKey(cs.k)\n  }\n\n  protected setNonce (cs: CipherState, nonce: uint32): void {\n    cs.n = nonce\n  }\n\n  protected createEmptyKey (): bytes32 {\n    return Buffer.alloc(32)\n  }\n\n  protected isEmptyKey (k: bytes32): boolean {\n    const emptyKey = this.createEmptyKey()\n    return emptyKey.equals(k)\n  }\n\n  protected incrementNonce (n: uint32): uint32 {\n    return n + 1\n  }\n\n  protected nonceToBytes (n: uint32): bytes {\n    const nonce = Buffer.alloc(12)\n    nonce.writeUInt32LE(n, 4)\n\n    return nonce\n  }\n\n  protected encrypt (k: bytes32, n: uint32, ad: bytes, plaintext: bytes): bytes {\n    const nonce = this.nonceToBytes(n)\n    const ctx = new ChaCha20Poly1305(k)\n    const encryptedMessage = ctx.seal(nonce, plaintext, ad)\n    return Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length)\n  }\n\n  protected encryptAndHash (ss: SymmetricState, plaintext: bytes): bytes {\n    let ciphertext\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext)\n    } else {\n      ciphertext = plaintext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return ciphertext\n  }\n\n  protected decrypt (k: bytes32, n: uint32, ad: bytes, ciphertext: bytes): {plaintext: bytes, valid: boolean} {\n    const nonce = this.nonceToBytes(n)\n    const ctx = new ChaCha20Poly1305(k)\n    const encryptedMessage = ctx.open(\n      nonce,\n      ciphertext,\n      ad\n    )\n    if (encryptedMessage) {\n      return {\n        plaintext: Buffer.from(\n          encryptedMessage.buffer,\n          encryptedMessage.byteOffset,\n          encryptedMessage.length\n        ),\n        valid: true\n      }\n    } else {\n      return {\n        plaintext: Buffer.from(''),\n        valid: false\n      }\n    }\n  }\n\n  protected decryptAndHash (ss: SymmetricState, ciphertext: bytes): {plaintext: bytes, valid: boolean} {\n    let plaintext: bytes; let valid = true\n    if (this.hasKey(ss.cs)) {\n      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext))\n    } else {\n      plaintext = ciphertext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return { plaintext, valid }\n  }\n\n  protected dh (privateKey: bytes32, publicKey: bytes32): bytes32 {\n    try {\n      const derivedU8 = x25519.sharedKey(privateKey, publicKey)\n      const derived = Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length)\n      const result = Buffer.alloc(32)\n      derived.copy(result)\n      return result\n    } catch (e) {\n      logger(e.message)\n      return Buffer.alloc(32)\n    }\n  }\n\n  protected mixHash (ss: SymmetricState, data: bytes): void {\n    ss.h = this.getHash(ss.h, data)\n  }\n\n  protected getHash (a: bytes, b: bytes): bytes32 {\n    const hash = SHA256.hash(Buffer.from([...a, ...b]))\n    return Buffer.from(hash.buffer, hash.byteOffset, hash.length)\n  }\n\n  protected mixKey (ss: SymmetricState, ikm: bytes32): void {\n    const [ck, tempK] = getHkdf(ss.ck, ikm)\n    ss.cs = this.initializeKey(tempK)\n    ss.ck = ck\n  }\n\n  protected initializeKey (k: bytes32): CipherState {\n    const n = MIN_NONCE\n    return { k, n }\n  }\n\n  // Symmetric state related\n\n  protected initializeSymmetric (protocolName: string): SymmetricState {\n    const protocolNameBytes: bytes = Buffer.from(protocolName, 'utf-8')\n    const h = this.hashProtocolName(protocolNameBytes)\n\n    const ck = h\n    const key = this.createEmptyKey()\n    const cs: CipherState = this.initializeKey(key)\n\n    return { cs, ck, h }\n  }\n\n  protected hashProtocolName (protocolName: bytes): bytes32 {\n    if (protocolName.length <= 32) {\n      const h = Buffer.alloc(32)\n      protocolName.copy(h)\n      return h\n    } else {\n      return this.getHash(protocolName, Buffer.alloc(0))\n    }\n  }\n\n  protected split (ss: SymmetricState): {cs1: CipherState, cs2: CipherState} {\n    const [tempk1, tempk2] = getHkdf(ss.ck, Buffer.alloc(0))\n    const cs1 = this.initializeKey(tempk1)\n    const cs2 = this.initializeKey(tempk2)\n\n    return { cs1, cs2 }\n  }\n\n  protected writeMessageRegular (cs: CipherState, payload: bytes): MessageBuffer {\n    const ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload)\n    const ne = this.createEmptyKey()\n    const ns = Buffer.alloc(0)\n\n    return { ne, ns, ciphertext }\n  }\n\n  protected readMessageRegular (cs: CipherState, message: MessageBuffer): {plaintext: bytes, valid: boolean} {\n    return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext)\n  }\n}\n"]}},"error":null,"hash":"da64ebbb845a87c628d1a31af18cb464","cacheData":{"env":{}}}