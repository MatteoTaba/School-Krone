{"id":"../node_modules/@chainsafe/libp2p-noise/dist/src/keycache.js","dependencies":[{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\dist\\src\\keycache.js.map","includedInParent":true,"mtime":1638722720528},{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\src\\keycache.ts","includedInParent":true,"mtime":1638722719663},{"name":"C:\\Users\\matte\\Documents\\SKR\\package.json","includedInParent":true,"mtime":1638722727563},{"name":"C:\\Users\\matte\\Documents\\SKR\\node_modules\\@chainsafe\\libp2p-noise\\package.json","includedInParent":true,"mtime":1638722719245}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyCache = void 0;\n/**\n * Storage for static keys of previously connected peers.\n */\nclass Keycache {\n    constructor() {\n        this.storage = new Map();\n    }\n    store(peerId, key) {\n        this.storage.set(peerId.id, key);\n    }\n    load(peerId) {\n        var _a;\n        if (!peerId) {\n            return null;\n        }\n        return (_a = this.storage.get(peerId.id)) !== null && _a !== void 0 ? _a : null;\n    }\n    resetStorage() {\n        this.storage.clear();\n    }\n}\nconst KeyCache = new Keycache();\nexports.KeyCache = KeyCache;\n"},"sourceMaps":{"js":{"version":3,"file":"keycache.js","sourceRoot":"","sources":["../../src/keycache.ts"],"names":[],"mappings":";;;AAGA;;GAEG;AACH,MAAM,QAAQ;IAAd;QACmB,YAAO,GAAG,IAAI,GAAG,EAAuB,CAAA;IAgB3D,CAAC;IAdQ,KAAK,CAAE,MAAc,EAAE,GAAY;QACxC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA;IAClC,CAAC;IAEM,IAAI,CAAE,MAAe;;QAC1B,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,MAAA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,mCAAI,IAAI,CAAA;IAC5C,CAAC;IAEM,YAAY;QACjB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAA;IACtB,CAAC;CACF;AAED,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAA;AAE7B,4BAAQ","sourcesContent":["import { bytes32 } from './@types/basic'\nimport PeerId from 'peer-id'\n\n/**\n * Storage for static keys of previously connected peers.\n */\nclass Keycache {\n  private readonly storage = new Map<Uint8Array, bytes32>()\n\n  public store (peerId: PeerId, key: bytes32): void {\n    this.storage.set(peerId.id, key)\n  }\n\n  public load (peerId?: PeerId): bytes32 | null {\n    if (!peerId) {\n      return null\n    }\n    return this.storage.get(peerId.id) ?? null\n  }\n\n  public resetStorage (): void {\n    this.storage.clear()\n  }\n}\n\nconst KeyCache = new Keycache()\nexport {\n  KeyCache\n}\n"]}},"error":null,"hash":"f22eac031b3a7f43ad32c8789e721a93","cacheData":{"env":{}}}